<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# cmd

```go
import "vuln-scan-api/cmd"
```

## Index

- [func RequestHandler\(ctx \*fasthttp.RequestCtx\)](<#RequestHandler>)
- [func StartServer\(\) \*fasthttp.Server](<#StartServer>)
- [func handleGenericRequest\[T any\]\(ctx \*fasthttp.RequestCtx, parseArgs func\(\[\]byte\) \(\*T, error\), process func\(\*T\) \(\[\]byte, error\)\)](<#handleGenericRequest>)
- [func handleQuery\(ctx \*fasthttp.RequestCtx\)](<#handleQuery>)
- [func handleScan\(ctx \*fasthttp.RequestCtx\)](<#handleScan>)
- [func isPostRequest\(ctx \*fasthttp.RequestCtx\) bool](<#isPostRequest>)
- [func main\(\)](<#main>)
- [func send200\(ctx \*fasthttp.RequestCtx\)](<#send200>)
- [func send400\(ctx \*fasthttp.RequestCtx\)](<#send400>)
- [func send404\(ctx \*fasthttp.RequestCtx\)](<#send404>)
- [func send500\(ctx \*fasthttp.RequestCtx\)](<#send500>)


<a name="RequestHandler"></a>
## func RequestHandler

```go
func RequestHandler(ctx *fasthttp.RequestCtx)
```

RequestHandler handles incoming HTTP requests and routes them to the appropriate handler based on the URI path. Input: ctx \- the context of the incoming HTTP request

<a name="StartServer"></a>
## func StartServer

```go
func StartServer() *fasthttp.Server
```

StartServer initializes and starts the HTTP server. Output: returns the initialized HTTP server

<a name="handleGenericRequest"></a>
## func handleGenericRequest

```go
func handleGenericRequest[T any](ctx *fasthttp.RequestCtx, parseArgs func([]byte) (*T, error), process func(*T) ([]byte, error))
```

handleGenericRequest processes a generic request by parsing arguments and processing them ctx: the context of the incoming HTTP request parseArgs: function to parse request body into arguments process: function to process the parsed arguments

<a name="handleQuery"></a>
## func handleQuery

```go
func handleQuery(ctx *fasthttp.RequestCtx)
```

handleQuery handles the /query endpoint by processing query requests ctx: the context of the incoming HTTP request

<a name="handleScan"></a>
## func handleScan

```go
func handleScan(ctx *fasthttp.RequestCtx)
```

handleScan handles the /scan endpoint by processing scan requests ctx: the context of the incoming HTTP request

<a name="isPostRequest"></a>
## func isPostRequest

```go
func isPostRequest(ctx *fasthttp.RequestCtx) bool
```

isPostRequest checks if the incoming HTTP request is a POST request. Input: ctx \- the context of the incoming HTTP request Output: returns true if the request method is POST, otherwise false

<a name="main"></a>
## func main

```go
func main()
```



<a name="send200"></a>
## func send200

```go
func send200(ctx *fasthttp.RequestCtx)
```

send200 sends a 200 OK response. Input: ctx \- the context of the incoming HTTP request

<a name="send400"></a>
## func send400

```go
func send400(ctx *fasthttp.RequestCtx)
```

send400 sends a 400 Bad Request response. Input: ctx \- the context of the incoming HTTP request

<a name="send404"></a>
## func send404

```go
func send404(ctx *fasthttp.RequestCtx)
```

send404 sends a 404 Not Found response. Input: ctx \- the context of the incoming HTTP request

<a name="send500"></a>
## func send500

```go
func send500(ctx *fasthttp.RequestCtx)
```

send500 sends a 500 Internal Server Error response. Input: ctx \- the context of the incoming HTTP request

# commands

```go
import "vuln-scan-api/internal/commands"
```

## Index

- [Variables](<#variables>)
- [func WaitForScan\(\)](<#WaitForScan>)
- [func addVulnToDB\(resp \*github.RawFileContent, file string\) error](<#addVulnToDB>)
- [type QueryArgs](<#QueryArgs>)
  - [func NewQueryArgs\(data \[\]byte\) \(\*QueryArgs, error\)](<#NewQueryArgs>)
  - [func \(q \*QueryArgs\) GetVulnsBySeverity\(\) \(ret \[\]byte, err error\)](<#QueryArgs.GetVulnsBySeverity>)
- [type ScanArgs](<#ScanArgs>)
  - [func NewScanArgs\(data \[\]byte\) \(\*ScanArgs, error\)](<#NewScanArgs>)
  - [func \(s \*ScanArgs\) RunScan\(\) \(\[\]byte, error\)](<#ScanArgs.RunScan>)
  - [func \(s \*ScanArgs\) SanitizeRepo\(\) error](<#ScanArgs.SanitizeRepo>)
  - [func \(s \*ScanArgs\) isScanRunning\(\) bool](<#ScanArgs.isScanRunning>)
  - [func \(s \*ScanArgs\) startScanIfNotRunning\(\) \(bool, error\)](<#ScanArgs.startScanIfNotRunning>)


## Variables

<a name="isScanRunning"></a>

```go
var (
    // True if a scan is already running. False otherwise
    isScanRunning bool = false

    // Lock when isScanRunning is to be accessed
    scanRunningLock sync.RWMutex = sync.RWMutex{}
)
```

<a name="WaitForScan"></a>
## func WaitForScan

```go
func WaitForScan()
```

WaitForScan waits for the current scan to complete. Only used in tests

<a name="addVulnToDB"></a>
## func addVulnToDB

```go
func addVulnToDB(resp *github.RawFileContent, file string) error
```

addVulnToDB adds vulnerabilities to the database. resp: the raw file content from GitHub. file: the file name. Returns an error if database operations fail.

<a name="QueryArgs"></a>
## type QueryArgs

QueryArgs parses the POST body from /query

```go
type QueryArgs struct {
    Filters database.Filters `json:"filters"`
}
```

<a name="NewQueryArgs"></a>
### func NewQueryArgs

```go
func NewQueryArgs(data []byte) (*QueryArgs, error)
```

NewQueryArgs creates a new QueryArgs instance from JSON data data: JSON byte array containing the query arguments returns: a pointer to QueryArgs and an error if parsing fails

<a name="QueryArgs.GetVulnsBySeverity"></a>
### func \(\*QueryArgs\) GetVulnsBySeverity

```go
func (q *QueryArgs) GetVulnsBySeverity() (ret []byte, err error)
```

GetVulnsBySeverity retrieves vulnerabilities by severity based on the filters The response must be sanitized to avoid leaking internals returns: a JSON byte array of vulnerabilities and an error if any occurs

<a name="ScanArgs"></a>
## type ScanArgs

QueryArgs parses the POST body from /scan

```go
type ScanArgs struct {
    Repo  string   `json:"repo"`
    Files []string `json:"files"`
}
```

<a name="NewScanArgs"></a>
### func NewScanArgs

```go
func NewScanArgs(data []byte) (*ScanArgs, error)
```

NewScanArgs creates a new ScanArgs instance from JSON data data: JSON byte array containing the query arguments returns: a pointer to ScanArgs and an error if parsing fails

<a name="ScanArgs.RunScan"></a>
### func \(\*ScanArgs\) RunScan

```go
func (s *ScanArgs) RunScan() ([]byte, error)
```

RunScan runs the scan in background and returns a sanitized response / error message The response should be sanitized to avoid leaking internal errors

<a name="ScanArgs.SanitizeRepo"></a>
### func \(\*ScanArgs\) SanitizeRepo

```go
func (s *ScanArgs) SanitizeRepo() error
```

SanitizeRepo sanitizes the repository URL in ScanArgs. Returns an error if URL parsing fails.

<a name="ScanArgs.isScanRunning"></a>
### func \(\*ScanArgs\) isScanRunning

```go
func (s *ScanArgs) isScanRunning() bool
```

isScanRunning checks if a scan is currently running. Returns true if a scan is running, false otherwise.

<a name="ScanArgs.startScanIfNotRunning"></a>
### func \(\*ScanArgs\) startScanIfNotRunning

```go
func (s *ScanArgs) startScanIfNotRunning() (bool, error)
```

startScanIfNotRunning runs the vulnerability scan and updates the database. Returns a boolean indicating if the scan started and an error if any.

# database

```go
import "vuln-scan-api/internal/database"
```

## Index

- [Variables](<#variables>)
- [func DeleteDb\(\)](<#DeleteDb>)
- [func Initialize\(\)](<#Initialize>)
- [type Filters](<#Filters>)
- [type SqliteConn](<#SqliteConn>)
  - [func NewConn\(\) \*SqliteConn](<#NewConn>)
  - [func \(s \*SqliteConn\) AddVulnsToDb\(tx \*sql.Tx, vuln \[\]Vulnerabilities, sourceFile string, scanTime time.Time\) error](<#SqliteConn.AddVulnsToDb>)
  - [func \(s \*SqliteConn\) Close\(\)](<#SqliteConn.Close>)
  - [func \(s \*SqliteConn\) GetTx\(\) \(\*sql.Tx, error\)](<#SqliteConn.GetTx>)
  - [func \(s \*SqliteConn\) GetVulnBySeverity\(filters Filters\) \(\[\]Vulnerabilities, error\)](<#SqliteConn.GetVulnBySeverity>)
- [type Vulnerabilities](<#Vulnerabilities>)


## Variables

<a name="insertQuery"></a>

```go
var insertQuery string = `
INSERT INTO vulnerabilities (
	id, severity, cvss, status, package_name, current_version, fixed_version,
	description, published_date, link, risk_factors, source_file, scan_time
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);
`
```

<a name="severityFilterQuery"></a>

```go
var severityFilterQuery string = `SELECT id, severity, cvss, status, package_name, current_version, fixed_version,
					description, published_date, link, risk_factors
					FROM vulnerabilities WHERE 1=1 `
```

<a name="DeleteDb"></a>
## func DeleteDb

```go
func DeleteDb()
```

DeleteDb deletes the database files. Only used for testing

<a name="Initialize"></a>
## func Initialize

```go
func Initialize()
```

Initialize sets up the database connection and creates necessary tables.

<a name="Filters"></a>
## type Filters

Filters represents the criteria used to filter vulnerabilities.

```go
type Filters struct {
    Severity *string `json:"severity"` // Severity level to filter vulnerabilities.
}
```

<a name="SqliteConn"></a>
## type SqliteConn



```go
type SqliteConn struct {
    db *sql.DB
}
```

<a name="NewConn"></a>
### func NewConn

```go
func NewConn() *SqliteConn
```

NewConn creates a new database connection. returns: a pointer to SqliteConn

<a name="SqliteConn.AddVulnsToDb"></a>
### func \(\*SqliteConn\) AddVulnsToDb

```go
func (s *SqliteConn) AddVulnsToDb(tx *sql.Tx, vuln []Vulnerabilities, sourceFile string, scanTime time.Time) error
```

AddVulnsToDb adds vulnerabilities to the database. tx: the database transaction vuln: slice of Vulnerabilities to add sourceFile: the source file name scanTime: the time of the scan returns: an error if adding vulnerabilities to DB fails

<a name="SqliteConn.Close"></a>
### func \(\*SqliteConn\) Close

```go
func (s *SqliteConn) Close()
```

Close closes the database connection.

<a name="SqliteConn.GetTx"></a>
### func \(\*SqliteConn\) GetTx

```go
func (s *SqliteConn) GetTx() (*sql.Tx, error)
```

GetTx starts a new database transaction. returns: a pointer to sql.Tx and an error if starting the transaction fails

<a name="SqliteConn.GetVulnBySeverity"></a>
### func \(\*SqliteConn\) GetVulnBySeverity

```go
func (s *SqliteConn) GetVulnBySeverity(filters Filters) ([]Vulnerabilities, error)
```

GetVulnBySeverity retrieves vulnerabilities filtered by severity. filters: the filters to apply to the query returns: a slice of Vulnerabilities and an error if the query fails

<a name="Vulnerabilities"></a>
## type Vulnerabilities

Vulnerabilities represents the necessary details needed to be stored in the DB

```go
type Vulnerabilities struct {
    ID             string    `json:"id"`
    Severity       string    `json:"severity"`
    Cvss           float64   `json:"cvss"`
    Status         string    `json:"status"`
    PackageName    string    `json:"package_name"`    // Name of the affected package.
    CurrentVersion string    `json:"current_version"` // Version of the package that is currently in use.
    FixedVersion   string    `json:"fixed_version"`   // Version of the package where the vulnerability is fixed.
    Description    string    `json:"description"`     // Description of the vulnerability.
    PublishedDate  time.Time `json:"published_date"`  // Date when the vulnerability was published.
    Link           string    `json:"link"`
    RiskFactors    []string  `json:"risk_factors"` // List of risk factors associated with the vulnerability. Stored as a json string.
}
```

# github

```go
import "vuln-scan-api/internal/github"
```

## Index

- [type RawFileContent](<#RawFileContent>)
  - [func GetFileContent\(root string, file string\) \(\*RawFileContent, error\)](<#GetFileContent>)


<a name="RawFileContent"></a>
## type RawFileContent

RawFileContent represents the structure of JSON file to be scanned

```go
type RawFileContent []struct {
    ScanResults struct {
        ScanID          string                     `json:"scan_id"`
        Timestamp       time.Time                  `json:"timestamp"`
        ScanStatus      string                     `json:"scan_status"`
        ResourceType    string                     `json:"resource_type"`
        ResourceName    string                     `json:"resource_name"`
        Vulnerabilities []database.Vulnerabilities `json:"vulnerabilities"`
        Summary         struct {
            TotalVulnerabilities int `json:"total_vulnerabilities"`
            SeverityCounts       struct {
                CRITICAL int `json:"CRITICAL"`
                HIGH     int `json:"HIGH"`
                MEDIUM   int `json:"MEDIUM"`
                LOW      int `json:"LOW"`
            }   `json:"severity_counts"`
            FixableCount int  `json:"fixable_count"`
            Compliant    bool `json:"compliant"`
        }   `json:"summary"`
        ScanMetadata struct {
            ScannerVersion  string   `json:"scanner_version"`
            PoliciesVersion string   `json:"policies_version"`
            ScanningRules   []string `json:"scanning_rules"`
            ExcludedPaths   []string `json:"excluded_paths"`
        }   `json:"scan_metadata"`
    } `json:"scanResults"`
}
```

<a name="GetFileContent"></a>
### func GetFileContent

```go
func GetFileContent(root string, file string) (*RawFileContent, error)
```

GetFileContent fetches the content of a file from a GitHub repository root: the root path of the GitHub repository file: the file path within the repository returns: a pointer to RawFileContent and an error if fetching fails

# httpclient

```go
import "vuln-scan-api/internal/httpclient"
```

## Index

- [Variables](<#variables>)
- [type Client](<#Client>)
  - [func NewClient\[T any\]\(\) Client\[T\]](<#NewClient>)
  - [func \(c \*Client\[T\]\) Get\(url string\) \(\*T, error\)](<#Client[T].Get>)


## Variables

<a name="readTimeout"></a>

```go
var (
    readTimeout         time.Duration = time.Millisecond * 500
    writeTimeout        time.Duration = time.Millisecond * 500
    maxIdleConnDuration time.Duration = time.Second * 5
)
```

<a name="Client"></a>
## type Client



```go
type Client[T any] struct {
    client *fasthttp.Client
}
```

<a name="NewClient"></a>
### func NewClient

```go
func NewClient[T any]() Client[T]
```

NewClient creates a new HTTP client with specified timeouts returns: a new instance of Client

<a name="Client[T].Get"></a>
### func \(\*Client\[T\]\) Get

```go
func (c *Client[T]) Get(url string) (*T, error)
```

Get sends a GET request to the specified URL and decodes the response url: the URL to send the GET request to returns: a pointer to the decoded response and an error if the request fails

# logger

```go
import "vuln-scan-api/internal/logger"
```

## Index

- [Variables](<#variables>)
- [func CreateLogger\(\)](<#CreateLogger>)


## Variables

<a name="Logger"></a>Create a new logger

```go
var Logger = slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{
    Level: slog.LevelError,
}))
```

<a name="CreateLogger"></a>
## func CreateLogger

```go
func CreateLogger()
```

CreateLogger creates a new logger

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
